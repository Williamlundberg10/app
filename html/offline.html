<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>GitHub Token Encoder/Decoder</title>
<style>
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; max-width: 900px; margin: 24px auto; padding: 0 18px; }
textarea,input { width:100%; font-family: monospace; box-sizing: border-box; margin-top:6px; }
.row { display:flex; gap:12px; margin-top: 6px; }
.col { flex:1; }
button { margin-top:8px; }
pre { background:#f6f6f6; padding:12px; border-radius:6px; overflow:auto; }
label small { display:block; color: #666; }
</style>
</head>
<body>
<h1>GitHub Token Encoder / Decoder</h1>

<label>
Secret (kept locally in browser)
<input id="secret" type="password" placeholder="Enter secret (never uploaded)"/>
</label>

<label>
<input id="persistSecret" type="checkbox"/> Persist secret in localStorage (less secure)
</label>

<h2>Encode GitHub Token</h2>
<label>
GitHub Token:
<input id="githubToken" type="text" placeholder="Enter GitHub token"/>
</label>
<button id="encodeBtn">Encode GitHub Token</button>

<h2>Candidate Tokens (decode & verify)</h2>
<label>
Paste tokens (one per line):
<textarea id="candidates" rows="6" placeholder="Paste candidate tokens here..."></textarea>
</label>

<div class="row">
<div class="col"><button id="decodeBtn">Decode candidates</button></div>
<div class="col"><button id="generateDecoy">Generate decoy token</button></div>
</div>

<h3>Result</h3>
<pre id="result">No action yet.</pre>

<script>
// --- helpers: base64url encode/decode ---
function base64UrlEncodeFromBytes(bytes) {
    let binary = "";
    const chunk = 0x8000;
    for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
    }
    const b = btoa(binary);
    return b.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}

function base64UrlDecodeToBytes(str) {
    str = str.replace(/-/g,'+').replace(/_/g,'/');
    while (str.length % 4) str += '=';
    const bin = atob(str);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
    return arr;
}

function bytesEqualConstant(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];
    return diff === 0;
}

// --- Web Crypto ---
async function importHmacKey(secret) {
    const enc = new TextEncoder().encode(secret);
    return crypto.subtle.importKey('raw', enc, {name: 'HMAC', hash: 'SHA-256'}, false, ['sign','verify']);
}

async function signPayload(payloadBytes, secret) {
    const key = await importHmacKey(secret);
    const sig = await crypto.subtle.sign('HMAC', key, payloadBytes);
    return new Uint8Array(sig);
}

async function verifyByRecalc(token, secret) {
    try {
        if (!token || token.indexOf('.') === -1) return false;
        const [p, s] = token.split('.');
        const payloadBytes = base64UrlDecodeToBytes(p);
        const providedSig = base64UrlDecodeToBytes(s);
        const expectedSig = await signPayload(payloadBytes, secret);
        return bytesEqualConstant(expectedSig, providedSig);
    } catch (e) {
        return false;
    }
}

async function decodeValidatedPayload(token) {
    const [p] = token.split('.');
    const payloadBytes = base64UrlDecodeToBytes(p);
    const text = new TextDecoder().decode(payloadBytes);
    try { return JSON.parse(text); } catch(e){ return text; }
}

// --- token creation helpers ---
function makeRandomDecoy() {
    const payload = JSON.stringify({ decoy:true, ts: Date.now(), rnd: Math.random().toString(36).slice(2) });
    const payloadBytes = new TextEncoder().encode(payload);
    const sig = crypto.getRandomValues(new Uint8Array(32));
    return base64UrlEncodeFromBytes(payloadBytes) + "." + base64UrlEncodeFromBytes(sig);
}

async function makeRealToken(payloadObj, secret) {
    const payloadJson = JSON.stringify(payloadObj);
    const payloadBytes = new TextEncoder().encode(payloadJson);
    const sigBytes = await signPayload(payloadBytes, secret);
    return base64UrlEncodeFromBytes(payloadBytes) + "." + base64UrlEncodeFromBytes(sigBytes);
}

// --- UI ---
const secretInput = document.getElementById('secret');
const persistCheckbox = document.getElementById('persistSecret');
const githubTokenInput = document.getElementById('githubToken');
const candidatesInput = document.getElementById('candidates');
const encodeBtn = document.getElementById('encodeBtn');
const decodeBtn = document.getElementById('decodeBtn');
const generateDecoyBtn = document.getElementById('generateDecoy');
const resultEl = document.getElementById('result');

// load secret from localStorage
if(localStorage.getItem('tokenDecoder_secret')) {
    secretInput.value = localStorage.getItem('tokenDecoder_secret');
    persistCheckbox.checked = true;
}
persistCheckbox.addEventListener('change', ()=>{
    if(!persistCheckbox.checked) localStorage.removeItem('tokenDecoder_secret');
    else if(secretInput.value) localStorage.setItem('tokenDecoder_secret', secretInput.value);
});
secretInput.addEventListener('input', ()=>{
    if(persistCheckbox.checked) localStorage.setItem('tokenDecoder_secret', secretInput.value);
});

// Encode GitHub token
encodeBtn.addEventListener('click', async ()=>{
    const secret = secretInput.value;
    const githubToken = githubTokenInput.value;
    if(!secret || !githubToken) { resultEl.textContent='Enter secret and GitHub token first.'; return; }
    const token = await makeRealToken({type:"github", token:githubToken}, secret);
    const existing = candidatesInput.value ? candidatesInput.value + "\n" + token : token;
    candidatesInput.value = existing;
    resultEl.textContent = 'Encoded GitHub token appended to candidates:\n' + token;
});

// Decode candidate tokens
decodeBtn.addEventListener('click', async ()=>{
    resultEl.textContent='Decoding...';
    const secret = secretInput.value;
    if(!secret) { resultEl.textContent='[!] Enter secret locally.'; return; }
    const lines = candidatesInput.value.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    if(!lines.length){ resultEl.textContent='[!] Paste candidate tokens first.'; return; }

    let found = null;
    for(const t of lines){
        if(await verifyByRecalc(t, secret)){ found = t; break; }
    }
    if(!found){ resultEl.textContent='No valid token found among candidates.'; return; }
    const payload = await decodeValidatedPayload(found);
    resultEl.textContent = 'VALID token found!\n\n' + JSON.stringify(payload, null, 2);
});

// Generate decoy token
generateDecoyBtn.addEventListener('click', ()=>{
    const decoy = makeRandomDecoy();
    const existing = candidatesInput.value ? candidatesInput.value + "\n" + decoy : decoy;
    candidatesInput.value = existing;
    resultEl.textContent = 'Decoy token appended to candidates.';
});
</script>
</body>
</html>
